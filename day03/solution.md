# Understanding, Defining and Managing Resources with Terraform

Hello Everyone! As we step into the third day of #TerraWeek today, our journey takes us deeper into the world of Terraform as we delve into understanding resource definition and management. We will embark on an exploration of diverse resource categories and their respective configurations. Furthermore, we shall briefly discuss resource interdependencies, *provisioners, and the art of lifecycle management. 
As we conclude this guide, you'll find yourself equipped with a firm understanding of these pivotal Terraform concepts. Let's commence our learning adventure!

## Table of Contents
- [Understanding, Defining and Managing Resources with Terraform](##understanding-defining-and-managing-resources-with-terraform)
- [Check State Files and Validate your .tf File](#check-state-files-and-validate-your-tf-file)
- [Provisioners](#provisioners)
- [Lifecycle Management](#lifecycle-management)
- [Conclusion](#conclusion)


## **Understanding, Defining and Managing Resources with Terraform**

You can choose AWS, Azure or GCP. I am going to work with AWS. <br> 

**1. Create a Ubuntu Machine on AWS**
**2. Install Terraform on your EC2 Ubuntu instance**
Verify the installation using **terraform â€” version:**
**3. Set Up AWS Credentials:**
- Sign in to the AWS Management Console.
- Create an IAM user or use an existing one with appropriate permissions for managing AWS resources. Ensure the user has permissions for EC2, VPC, S3, and other services you plan
  to work with. For now, I am giving "Administrator Access".

  ![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/63bbf69f-a3d3-471c-a316-8a3fb7a46e83)

- Generate an **access key and secret key** for the IAM user. Save it somewhere or download **.csv** as you will not be able to see it afterwards.
- Configure the **AWS CLI** on your EC2 instance by running **aws configure** command. Give the access key and secret key for the user that you create.

![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/4738bdc5-ae27-463b-9ee5-23ed5049c91d)

**4. Create Terraform configuration file:**

- Create a new directory for your Terraform configuration files.
- Open a terminal and navigate to the new directory.
- Create a new Terraform configuration file with an .tf extension. 
- In the configuration file, specify the AWS provider and any resources you want to create or manage. Any variables you wants to define.

This is how my folder structure looks like:
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/e950e2b1-4bdd-4658-a83d-5f288a0faf42)

![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/27c6eaf5-8edc-4ecc-af81-53e7a75542cd)

![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/0cc657e5-a8a1-4df5-88ab-55854ef021b1)

![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/1cf15ae3-2daa-49a0-b88b-772cf12c5f50)

![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/7118f73b-82a7-40d9-89d1-7986439dc528)

![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/015cf122-d608-4a20-9c9b-87d214d53fe9)

### **Check State Files and Validate your .tf File**

Check state files before running plan and apply commands & Use validate command to validate your .tf file for errors and provide the Output generated by each commands.

1. Initialize the working directory using the init command:
```
terraform init
```
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/0cbe71b4-8ba1-4540-afaa-bf2dd0bfe397)

2. Check the existing state files to ensure that Terraform is aware of the current infrastructure:
```
terraform state list
```
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/cb0a777c-6d29-4371-b506-041f214f7923)

3. To validate your configuration file for any syntax errors, you can run:
```
terraform validate
```
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/5820ba67-ebe7-4f1e-8e50-400918821178)

8. Once youâ€™ve verified the state and validated the configuration file, you can proceed with the plan and apply commands.

```
terraform plan
```
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/fc77fb6a-1aab-41a6-b7a4-16145595f184)
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/2dce8f74-9f9d-4f17-aee0-f90284296c5d)

```
terraform apply
```
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/f60825c4-8614-4839-96bb-e06ea5822577)

We can also see the outputs in above screenshot:  **ec2_public_ips = "35.153.157.250"**

Here, you go! Our instance is provisioned and is initailizing
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/e1010116-7f42-481c-b8b5-d4daed9bce8b)

Now, let's check the **terraform state list**
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/9028bd24-d429-4081-ae87-a240b53a2168)

WOAH! We are able to connect to the instance as well ðŸ“½
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/edb6dbab-5c96-4780-8049-98f6b3774217)

6. **terraform destroy** command removes all the resources defined in the Terraform configuration, just one single command ðŸ«¡
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/ff6ee4a9-2d2f-48cd-9519-88b75425922f)
   
![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/1a03995f-fdf5-48e7-b795-c30103ff5aa9)


### **Provisioners**
Provisioners in Terraform are used to execute scripts or other actions on a local or remote machine as part of the resource creation or destruction process.
In below example, I am trying to execute a command on the local machine (local-exec).

![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/6993ac8a-57d7-49d9-87ca-d6b2298b55b7)

We need to update Terraform configuration file that includes the provisioner and run the **terraform apply** command.

![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/d4493725-cae0-4f59-892f-2a1d780872a5)

### **Lifecycle Management**

To add lifecycle management configurations **to control the creation, modification, and deletion of a resource in Terraform**, you can use the **lifecycle block** within the resource configuration.

- ***prevent_destroy:** Setting prevent_destroy to true prevents a resource from being destroyed. This can be used as a measure of safety against the accidental replacement of objects that may be costly to reproduce, such as database instances.

- ***create_before_destroy:** The create_before_destroy meta-argument changes this behavior so that the new replacement object is created first, and the prior object is destroyed after the replacement is created. 

- ***ignore_changes:** The ignore_changes argument within the lifecycle block is used to ignore changes to certain attributes of a resource, preventing Terraform from proposing these as part of the plan. This is particularly useful when you want to manage specific parts of your infrastructure outside of Terraform.

- **replace_triggered_by:** Replaces the resource when any of the referenced items change.
  References trigger replacement in the following conditions:
   - If the reference is to a resource with multiple instances, a plan to update or replace any instance will trigger replacement.
   - If the reference is to a single resource instance, a plan to update or replace that instance will trigger replacement.
   - If the reference is to a single attribute of a resource instance, any change to the attribute value will trigger replacement.

Let's see one of the example of using the lifecycle block to prevent the accidental destruction of an AWS EC2 instance.

![image](https://github.com/ashmisinha/TerraWeek/assets/66667107/69194c58-f0e9-43cd-ba3f-0d6192418296)

### **Conclusion:**

In this blog, we've delved into the art of resource management through Terraform, centering on different resource categories and their setup, including AWS EC2 instances. Additionally, we saw how provisioners, and lifecycle works. Equipped with this insight, we are well-prepared to efficiently orchestrate and oversee our infrastructure utilizing Terraform's robust features.

Happy Terraforming!:)
